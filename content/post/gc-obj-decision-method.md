---
title: "GC对象的判定方法"
date: 2020-04-16T23:33:38+08:00
categories: ["Java"]
tags: ["GC"]
---

在堆里面存放着`Java`世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经死去。
<!--more-->

### 引用计数法

引用计数法判断对象是否存活的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

客观的说，引用计数算法虽然占用了一些额外的内存空间来进行计数，但他的原理简单，判断效率也很高，在大多数情况下他都是一个不错的算法。但是在`Java`领域，至少主流的`Java`虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用技术就很难解决对象之间相互循环引用的问题。两个对象互相引用对方，导致它们的引用计数都不为零，即使这两个对象已经不可能再被访问，引用计数算法也无法回收它们。

### 可达性分析

当前主流的商用程序语言的内存管理子系统，都是通过可达性分析算法来判定对象是否存活。这个算法的基本思路就是通过一系列`GC Roots`的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链，如果某个对象到`GC Roots`间没有任何引用链相连，或者用图论的话来说就是从`GC Roots`到这个对象不可达时，则证明此对象是不可能再被使用的。

在`Java`技术体系里面，固定可作为`GC Roots`的对象包括以下几种：
- 在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、布局变量、临时变量等。
- 在方法区中类静态属性引用的对象，譬如`Java`类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池里的引用。
- 在本地方法栈中`JNI`引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的`Class`对象，一些常驻的异常对象(比如`NullPointException、OutOfMemoryError`)等，还有系统加载器。
- 所有被同步锁持有的对象。
- 反映`Java`虚拟机内部情况的`JMXBean`、`JVMTI`中注册的回调、本地代码缓存等。

即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与`GC Roots`相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行`finalize`方法。假如对象没有覆盖`finalize`方法，或者`finalize`方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定为确有必要执行`finalize`方法，那么该对象将会被放置在一个名为`F-Queue`的队列之中，并在稍后由一条虚拟机自动建立的、低调度优先级的`Finalizer`线程去执行它们的`finalize`方法。`finalize`方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对`F-Queue`中的对象进行第二次小规模标记，如果对象要在`finalize`中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，那在第二次标记是它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。
